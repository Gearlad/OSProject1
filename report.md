# Report

Group members: B06902101, B06902098	B05902099	B06902051	B05902132	B06902086

### Design
Our scheduler is in user space, so we need help from the Linux scheduler. The Linux scheduler provides a FIFO policy, processes under which has precedence over normal processes. Naturally, our scheduler and its children run under this policy, so other processes on the computer can't interference with our processes.  Processes has different priorities under FIFO policy, and those with a lower priority can't run if other processes with higher priorities are ready to run. We exploit this property to perform context switch. Our main scheduler runs in highest priority, and it makes sure there's always one child (assuming the scheduler has at least one child) in second highest priority, and the other children are in the lowest priority. When the schdeduler blocks, the child with highest priority gets chance to run.

Our program can be split into three parts. One part is responsible for initialization, one part is responsible for event handling, and one part is responsible for job scheduling. There's nothing to say about initialization. After the initialization is the event handling part. It watches for events such as arrival of new processes, time slice ending, or old process terminating. The first two events are handled using timers. It could be done by using two timers, but we choose to simulate two timers with one timer to practice our coding skills. All events generate signals, so a loop runing sigsuspend() is an obvious choice. By only unblocking signals in sigsuspend(), and since the scheduler process has the highest priority, we make sure that there's no race conditions. After being notified an event, the event handler does some necessarity work, such as resetting timer or calling wait(), it tells job scheduler to handle the events. After that, the event handler checks whether there are incoming children or currently running children, and if not, the event handler breaks from the loop.

The event handler notify an event to the job scheduler by calling add_process(), remove_current_process(), or timeslice_over(). Inside those functions is a switch statement that calls add_process_{policy}(), remove_current_process_{policy}(), depending on current policy. Since there may be multiple processes being added, the scheduler_empty_RR can't perform context switch yet. The event handler tells it it's time to perform context switch by calling context_switch_{policy}(). Another interface of the job scheduler is scheduler_empty_{policy}(), which is needed by the event handler to know whether it can stop waiting for events.

The FIFO scheduler does nearly nothing, as the scheduler and its children are already running under the kernel FIFO scheduler. All it does is remembering how many children are running, and tells the event handler whether there's still child waiting to be scheduled. The RR scheduler uses an array to store process information, and remembers what process to suspend and what process to continue. Both SJF scheduler and PSJF scheduler uses a heap to manage jobs. In SJF scheduler, every job in the heap has never runned. When the current job terminates, a new job is popped and will never be pushed back. In PSJF scheduler, (TODO: I HAVE TO SLEEP, FINISH THIS PART LATER)

The design try to seperate concerns into different part of code, and each part of code does not know each other too much. For example, the interface of job scheduler has very few parameters. remove_current_process() doens't even require the caller to provide a ProcessInfo! Because even in theory the event handler can know what process terminated by pid, it's not really the event handler's business. The event handler doesn't try to provide the PSJF scheduler any information about time, even if it can be useful. The PSJF scheduler can figure that out by itself. Since the interface only require minimum information and does not vary between policies, the event handling loop doesn't have to handle special cases. The only part that differs depending on policy is the timer part, as only RR requres an addtional timer. And that's because we try to simulate two timers with only one timer. The code can be even more elegant if we used two timers (which we obviously should, but that way it's less fun.)

Sadly, the abstraction still end up being leaky. For example, it's not clear that which part of the code should be resposible for forking. The job sheduler should be only one that sets priority of children, but as we end up choosing let event handler do forking, and after forking the priority should be set immediatly, event handler also sets priority of children. It's also not satisfactory that event handler has to explicitly call context_switch().

### Contributions
Jason designed the program architecture, wrote the system calls and studied Linux FIFO scheduler.
Michial designed the timer.
Naveno and Seth designed the SJF and PSJF scheduling algorithms
Seth created the header file, added functions for debugging, input, and split the functions among several classes.
Shally and Annjee designed the RR and FIFO scheduling algorithms
